// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cassspeed.proto

#ifndef PROTOBUF_cassspeed_2eproto__INCLUDED
#define PROTOBUF_cassspeed_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace serviceCassSpeed {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cassspeed_2eproto();
void protobuf_AssignDesc_cassspeed_2eproto();
void protobuf_ShutdownFile_cassspeed_2eproto();

class samplesets;
class output;
class cassspeed;

// ===================================================================

class samplesets : public ::google::protobuf::Message {
 public:
  samplesets();
  virtual ~samplesets();

  samplesets(const samplesets& from);

  inline samplesets& operator=(const samplesets& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const samplesets& default_instance();

  void Swap(samplesets* other);

  // implements Message ----------------------------------------------

  samplesets* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const samplesets& from);
  void MergeFrom(const samplesets& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string compression = 2;
  inline bool has_compression() const;
  inline void clear_compression();
  static const int kCompressionFieldNumber = 2;
  inline const ::std::string& compression() const;
  inline void set_compression(const ::std::string& value);
  inline void set_compression(const char* value);
  inline void set_compression(const char* value, size_t size);
  inline ::std::string* mutable_compression();
  inline ::std::string* release_compression();
  inline void set_allocated_compression(::std::string* compression);

  // repeated float sample = 3 [packed = true];
  inline int sample_size() const;
  inline void clear_sample();
  static const int kSampleFieldNumber = 3;
  inline float sample(int index) const;
  inline void set_sample(int index, float value);
  inline void add_sample(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      sample() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_sample();

  // @@protoc_insertion_point(class_scope:serviceCassSpeed.samplesets)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_compression();
  inline void clear_has_compression();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* compression_;
  ::google::protobuf::RepeatedField< float > sample_;
  mutable int _sample_cached_byte_size_;
  friend void  protobuf_AddDesc_cassspeed_2eproto();
  friend void protobuf_AssignDesc_cassspeed_2eproto();
  friend void protobuf_ShutdownFile_cassspeed_2eproto();

  void InitAsDefaultInstance();
  static samplesets* default_instance_;
};
// -------------------------------------------------------------------

class output : public ::google::protobuf::Message {
 public:
  output();
  virtual ~output();

  output(const output& from);

  inline output& operator=(const output& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const output& default_instance();

  void Swap(output* other);

  // implements Message ----------------------------------------------

  output* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const output& from);
  void MergeFrom(const output& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string deviceid = 1;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 1;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // repeated .serviceCassSpeed.samplesets sampleset = 2;
  inline int sampleset_size() const;
  inline void clear_sampleset();
  static const int kSamplesetFieldNumber = 2;
  inline const ::serviceCassSpeed::samplesets& sampleset(int index) const;
  inline ::serviceCassSpeed::samplesets* mutable_sampleset(int index);
  inline ::serviceCassSpeed::samplesets* add_sampleset();
  inline const ::google::protobuf::RepeatedPtrField< ::serviceCassSpeed::samplesets >&
      sampleset() const;
  inline ::google::protobuf::RepeatedPtrField< ::serviceCassSpeed::samplesets >*
      mutable_sampleset();

  // @@protoc_insertion_point(class_scope:serviceCassSpeed.output)
 private:
  inline void set_has_deviceid();
  inline void clear_has_deviceid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* deviceid_;
  ::google::protobuf::RepeatedPtrField< ::serviceCassSpeed::samplesets > sampleset_;
  friend void  protobuf_AddDesc_cassspeed_2eproto();
  friend void protobuf_AssignDesc_cassspeed_2eproto();
  friend void protobuf_ShutdownFile_cassspeed_2eproto();

  void InitAsDefaultInstance();
  static output* default_instance_;
};
// -------------------------------------------------------------------

class cassspeed : public ::google::protobuf::Message {
 public:
  cassspeed();
  virtual ~cassspeed();

  cassspeed(const cassspeed& from);

  inline cassspeed& operator=(const cassspeed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cassspeed& default_instance();

  void Swap(cassspeed* other);

  // implements Message ----------------------------------------------

  cassspeed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cassspeed& from);
  void MergeFrom(const cassspeed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timeStampStart = 1;
  inline bool has_timestampstart() const;
  inline void clear_timestampstart();
  static const int kTimeStampStartFieldNumber = 1;
  inline ::google::protobuf::uint64 timestampstart() const;
  inline void set_timestampstart(::google::protobuf::uint64 value);

  // optional uint64 timeStampEnd = 2;
  inline bool has_timestampend() const;
  inline void clear_timestampend();
  static const int kTimeStampEndFieldNumber = 2;
  inline ::google::protobuf::uint64 timestampend() const;
  inline void set_timestampend(::google::protobuf::uint64 value);

  // optional float sampleIntervalMsec = 3;
  inline bool has_sampleintervalmsec() const;
  inline void clear_sampleintervalmsec();
  static const int kSampleIntervalMsecFieldNumber = 3;
  inline float sampleintervalmsec() const;
  inline void set_sampleintervalmsec(float value);

  // optional uint32 numSamples = 4;
  inline bool has_numsamples() const;
  inline void clear_numsamples();
  static const int kNumSamplesFieldNumber = 4;
  inline ::google::protobuf::uint32 numsamples() const;
  inline void set_numsamples(::google::protobuf::uint32 value);

  // optional int32 numDevices = 5;
  inline bool has_numdevices() const;
  inline void clear_numdevices();
  static const int kNumDevicesFieldNumber = 5;
  inline ::google::protobuf::int32 numdevices() const;
  inline void set_numdevices(::google::protobuf::int32 value);

  // repeated .serviceCassSpeed.output outputsets = 6;
  inline int outputsets_size() const;
  inline void clear_outputsets();
  static const int kOutputsetsFieldNumber = 6;
  inline const ::serviceCassSpeed::output& outputsets(int index) const;
  inline ::serviceCassSpeed::output* mutable_outputsets(int index);
  inline ::serviceCassSpeed::output* add_outputsets();
  inline const ::google::protobuf::RepeatedPtrField< ::serviceCassSpeed::output >&
      outputsets() const;
  inline ::google::protobuf::RepeatedPtrField< ::serviceCassSpeed::output >*
      mutable_outputsets();

  // optional int32 status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:serviceCassSpeed.cassspeed)
 private:
  inline void set_has_timestampstart();
  inline void clear_has_timestampstart();
  inline void set_has_timestampend();
  inline void clear_has_timestampend();
  inline void set_has_sampleintervalmsec();
  inline void clear_has_sampleintervalmsec();
  inline void set_has_numsamples();
  inline void clear_has_numsamples();
  inline void set_has_numdevices();
  inline void clear_has_numdevices();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestampstart_;
  ::google::protobuf::uint64 timestampend_;
  float sampleintervalmsec_;
  ::google::protobuf::uint32 numsamples_;
  ::google::protobuf::RepeatedPtrField< ::serviceCassSpeed::output > outputsets_;
  ::google::protobuf::int32 numdevices_;
  ::google::protobuf::int32 status_;
  friend void  protobuf_AddDesc_cassspeed_2eproto();
  friend void protobuf_AssignDesc_cassspeed_2eproto();
  friend void protobuf_ShutdownFile_cassspeed_2eproto();

  void InitAsDefaultInstance();
  static cassspeed* default_instance_;
};
// ===================================================================


// ===================================================================

// samplesets

// required string name = 1;
inline bool samplesets::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void samplesets::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void samplesets::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void samplesets::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& samplesets::name() const {
  // @@protoc_insertion_point(field_get:serviceCassSpeed.samplesets.name)
  return *name_;
}
inline void samplesets::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:serviceCassSpeed.samplesets.name)
}
inline void samplesets::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:serviceCassSpeed.samplesets.name)
}
inline void samplesets::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:serviceCassSpeed.samplesets.name)
}
inline ::std::string* samplesets::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:serviceCassSpeed.samplesets.name)
  return name_;
}
inline ::std::string* samplesets::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void samplesets::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:serviceCassSpeed.samplesets.name)
}

// optional string compression = 2;
inline bool samplesets::has_compression() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void samplesets::set_has_compression() {
  _has_bits_[0] |= 0x00000002u;
}
inline void samplesets::clear_has_compression() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void samplesets::clear_compression() {
  if (compression_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compression_->clear();
  }
  clear_has_compression();
}
inline const ::std::string& samplesets::compression() const {
  // @@protoc_insertion_point(field_get:serviceCassSpeed.samplesets.compression)
  return *compression_;
}
inline void samplesets::set_compression(const ::std::string& value) {
  set_has_compression();
  if (compression_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compression_ = new ::std::string;
  }
  compression_->assign(value);
  // @@protoc_insertion_point(field_set:serviceCassSpeed.samplesets.compression)
}
inline void samplesets::set_compression(const char* value) {
  set_has_compression();
  if (compression_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compression_ = new ::std::string;
  }
  compression_->assign(value);
  // @@protoc_insertion_point(field_set_char:serviceCassSpeed.samplesets.compression)
}
inline void samplesets::set_compression(const char* value, size_t size) {
  set_has_compression();
  if (compression_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compression_ = new ::std::string;
  }
  compression_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:serviceCassSpeed.samplesets.compression)
}
inline ::std::string* samplesets::mutable_compression() {
  set_has_compression();
  if (compression_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compression_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:serviceCassSpeed.samplesets.compression)
  return compression_;
}
inline ::std::string* samplesets::release_compression() {
  clear_has_compression();
  if (compression_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = compression_;
    compression_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void samplesets::set_allocated_compression(::std::string* compression) {
  if (compression_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete compression_;
  }
  if (compression) {
    set_has_compression();
    compression_ = compression;
  } else {
    clear_has_compression();
    compression_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:serviceCassSpeed.samplesets.compression)
}

// repeated float sample = 3 [packed = true];
inline int samplesets::sample_size() const {
  return sample_.size();
}
inline void samplesets::clear_sample() {
  sample_.Clear();
}
inline float samplesets::sample(int index) const {
  // @@protoc_insertion_point(field_get:serviceCassSpeed.samplesets.sample)
  return sample_.Get(index);
}
inline void samplesets::set_sample(int index, float value) {
  sample_.Set(index, value);
  // @@protoc_insertion_point(field_set:serviceCassSpeed.samplesets.sample)
}
inline void samplesets::add_sample(float value) {
  sample_.Add(value);
  // @@protoc_insertion_point(field_add:serviceCassSpeed.samplesets.sample)
}
inline const ::google::protobuf::RepeatedField< float >&
samplesets::sample() const {
  // @@protoc_insertion_point(field_list:serviceCassSpeed.samplesets.sample)
  return sample_;
}
inline ::google::protobuf::RepeatedField< float >*
samplesets::mutable_sample() {
  // @@protoc_insertion_point(field_mutable_list:serviceCassSpeed.samplesets.sample)
  return &sample_;
}

// -------------------------------------------------------------------

// output

// required string deviceid = 1;
inline bool output::has_deviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void output::set_has_deviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void output::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void output::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& output::deviceid() const {
  // @@protoc_insertion_point(field_get:serviceCassSpeed.output.deviceid)
  return *deviceid_;
}
inline void output::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set:serviceCassSpeed.output.deviceid)
}
inline void output::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set_char:serviceCassSpeed.output.deviceid)
}
inline void output::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:serviceCassSpeed.output.deviceid)
}
inline ::std::string* output::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:serviceCassSpeed.output.deviceid)
  return deviceid_;
}
inline ::std::string* output::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void output::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:serviceCassSpeed.output.deviceid)
}

// repeated .serviceCassSpeed.samplesets sampleset = 2;
inline int output::sampleset_size() const {
  return sampleset_.size();
}
inline void output::clear_sampleset() {
  sampleset_.Clear();
}
inline const ::serviceCassSpeed::samplesets& output::sampleset(int index) const {
  // @@protoc_insertion_point(field_get:serviceCassSpeed.output.sampleset)
  return sampleset_.Get(index);
}
inline ::serviceCassSpeed::samplesets* output::mutable_sampleset(int index) {
  // @@protoc_insertion_point(field_mutable:serviceCassSpeed.output.sampleset)
  return sampleset_.Mutable(index);
}
inline ::serviceCassSpeed::samplesets* output::add_sampleset() {
  // @@protoc_insertion_point(field_add:serviceCassSpeed.output.sampleset)
  return sampleset_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::serviceCassSpeed::samplesets >&
output::sampleset() const {
  // @@protoc_insertion_point(field_list:serviceCassSpeed.output.sampleset)
  return sampleset_;
}
inline ::google::protobuf::RepeatedPtrField< ::serviceCassSpeed::samplesets >*
output::mutable_sampleset() {
  // @@protoc_insertion_point(field_mutable_list:serviceCassSpeed.output.sampleset)
  return &sampleset_;
}

// -------------------------------------------------------------------

// cassspeed

// required uint64 timeStampStart = 1;
inline bool cassspeed::has_timestampstart() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cassspeed::set_has_timestampstart() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cassspeed::clear_has_timestampstart() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cassspeed::clear_timestampstart() {
  timestampstart_ = GOOGLE_ULONGLONG(0);
  clear_has_timestampstart();
}
inline ::google::protobuf::uint64 cassspeed::timestampstart() const {
  // @@protoc_insertion_point(field_get:serviceCassSpeed.cassspeed.timeStampStart)
  return timestampstart_;
}
inline void cassspeed::set_timestampstart(::google::protobuf::uint64 value) {
  set_has_timestampstart();
  timestampstart_ = value;
  // @@protoc_insertion_point(field_set:serviceCassSpeed.cassspeed.timeStampStart)
}

// optional uint64 timeStampEnd = 2;
inline bool cassspeed::has_timestampend() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cassspeed::set_has_timestampend() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cassspeed::clear_has_timestampend() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cassspeed::clear_timestampend() {
  timestampend_ = GOOGLE_ULONGLONG(0);
  clear_has_timestampend();
}
inline ::google::protobuf::uint64 cassspeed::timestampend() const {
  // @@protoc_insertion_point(field_get:serviceCassSpeed.cassspeed.timeStampEnd)
  return timestampend_;
}
inline void cassspeed::set_timestampend(::google::protobuf::uint64 value) {
  set_has_timestampend();
  timestampend_ = value;
  // @@protoc_insertion_point(field_set:serviceCassSpeed.cassspeed.timeStampEnd)
}

// optional float sampleIntervalMsec = 3;
inline bool cassspeed::has_sampleintervalmsec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cassspeed::set_has_sampleintervalmsec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cassspeed::clear_has_sampleintervalmsec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cassspeed::clear_sampleintervalmsec() {
  sampleintervalmsec_ = 0;
  clear_has_sampleintervalmsec();
}
inline float cassspeed::sampleintervalmsec() const {
  // @@protoc_insertion_point(field_get:serviceCassSpeed.cassspeed.sampleIntervalMsec)
  return sampleintervalmsec_;
}
inline void cassspeed::set_sampleintervalmsec(float value) {
  set_has_sampleintervalmsec();
  sampleintervalmsec_ = value;
  // @@protoc_insertion_point(field_set:serviceCassSpeed.cassspeed.sampleIntervalMsec)
}

// optional uint32 numSamples = 4;
inline bool cassspeed::has_numsamples() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cassspeed::set_has_numsamples() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cassspeed::clear_has_numsamples() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cassspeed::clear_numsamples() {
  numsamples_ = 0u;
  clear_has_numsamples();
}
inline ::google::protobuf::uint32 cassspeed::numsamples() const {
  // @@protoc_insertion_point(field_get:serviceCassSpeed.cassspeed.numSamples)
  return numsamples_;
}
inline void cassspeed::set_numsamples(::google::protobuf::uint32 value) {
  set_has_numsamples();
  numsamples_ = value;
  // @@protoc_insertion_point(field_set:serviceCassSpeed.cassspeed.numSamples)
}

// optional int32 numDevices = 5;
inline bool cassspeed::has_numdevices() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cassspeed::set_has_numdevices() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cassspeed::clear_has_numdevices() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cassspeed::clear_numdevices() {
  numdevices_ = 0;
  clear_has_numdevices();
}
inline ::google::protobuf::int32 cassspeed::numdevices() const {
  // @@protoc_insertion_point(field_get:serviceCassSpeed.cassspeed.numDevices)
  return numdevices_;
}
inline void cassspeed::set_numdevices(::google::protobuf::int32 value) {
  set_has_numdevices();
  numdevices_ = value;
  // @@protoc_insertion_point(field_set:serviceCassSpeed.cassspeed.numDevices)
}

// repeated .serviceCassSpeed.output outputsets = 6;
inline int cassspeed::outputsets_size() const {
  return outputsets_.size();
}
inline void cassspeed::clear_outputsets() {
  outputsets_.Clear();
}
inline const ::serviceCassSpeed::output& cassspeed::outputsets(int index) const {
  // @@protoc_insertion_point(field_get:serviceCassSpeed.cassspeed.outputsets)
  return outputsets_.Get(index);
}
inline ::serviceCassSpeed::output* cassspeed::mutable_outputsets(int index) {
  // @@protoc_insertion_point(field_mutable:serviceCassSpeed.cassspeed.outputsets)
  return outputsets_.Mutable(index);
}
inline ::serviceCassSpeed::output* cassspeed::add_outputsets() {
  // @@protoc_insertion_point(field_add:serviceCassSpeed.cassspeed.outputsets)
  return outputsets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::serviceCassSpeed::output >&
cassspeed::outputsets() const {
  // @@protoc_insertion_point(field_list:serviceCassSpeed.cassspeed.outputsets)
  return outputsets_;
}
inline ::google::protobuf::RepeatedPtrField< ::serviceCassSpeed::output >*
cassspeed::mutable_outputsets() {
  // @@protoc_insertion_point(field_mutable_list:serviceCassSpeed.cassspeed.outputsets)
  return &outputsets_;
}

// optional int32 status = 7;
inline bool cassspeed::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void cassspeed::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void cassspeed::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void cassspeed::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 cassspeed::status() const {
  // @@protoc_insertion_point(field_get:serviceCassSpeed.cassspeed.status)
  return status_;
}
inline void cassspeed::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:serviceCassSpeed.cassspeed.status)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace serviceCassSpeed

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cassspeed_2eproto__INCLUDED
